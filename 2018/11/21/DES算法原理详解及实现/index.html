<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> DES算法原理详解及实现 · ChengUU</title><meta name="description" content="DES算法原理详解及实现 - ChengUU"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/ChengUU/atom.xml" title="ChengUU"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">ChengUU</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>INDEX</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>ARCHIVES</p></a><a href="/categories" target="_self" class="li component-nav-item"><p>CATEGORIES</p></a><a href="/tags" target="_self" class="li component-nav-item"><p>TAGS</p></a><ul class="shortcut-icons"><a href="https://github.com/ChengUU" target="_blank"><img src="/images/github.svg" class="icon"></a><a href="/atom.xml" target="_blank"><img src="/images/rss.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">DES算法原理详解及实现</h1><div class="post-info">2018年11月21日</div><div class="post-content"><p>使用最广泛的加密体制是数据加密标准(Data　Encryption Standard)，它于1972年被美国国家标准局(National Bureau of Standard, NBS)，即现在的国家标准和技术协会(National Institute of Standard and Technology, NIST)采纳为联邦信息处理标准。DES是对称加密算法里面常见的一种，是一种使用密钥加密的块算法，密钥长度为64位(bits)，超出长度部分的密钥将会被截取丢弃。所谓对称加密，即加密和解密使用的密钥相同。对称性加密一般会按照固定长度，把待加密字符串分成块，不足一块的部分使用特殊字符填充。常见的加密模式有ECB,CBC,CTR,OFB,CFB,NCFB,NOFB。DES算法流程图如下：<br><br><img src="/images/DES算法流程图.png" alt="DES算法流程图"></p>
<h1 id="DES加密"><a href="#DES加密" class="headerlink" title="DES加密"></a>DES加密</h1><p>DES加密算法主要分为两部分和三个阶段，子密钥产生部分和左右数据交换部分，明文会经过如下三个阶段的处理，首先初始数据通过置换进行重新排列，然后通过相同的函数作用以及进行置换和代替处理，最后第１６轮输出的６４位数据进行左右互换，通过初始置换的逆置换得到最终的密文。</p>
<h2 id="子密钥产生"><a href="#子密钥产生" class="headerlink" title="子密钥产生"></a>子密钥产生</h2><p>初始密钥通过置换选择表PC1，将64位密钥减少至56位，同时将56位密钥分成C0、D0两部分，C0和D0都是28位。将C0、D0向左循环位移指定次数得到C1、D1，然后将二者进行拼接，再经过置换选择表PC2得到最终的48位子密钥。<br>迭代加密过程中，每一轮循环位移的次数不同(16轮)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//循环位移次数</span><br><span class="line">int DISPLACEMENT_TURNS[]=&#123;1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1&#125;;</span><br></pre></td></tr></table></figure></p>
<p>置换选择表PC1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//置换选择表１</span><br><span class="line">int PC_1[]=&#123;57,49,41,33,25,17,9,1,</span><br><span class="line">                    58,50,42,34,26,18,10,2,</span><br><span class="line">                    59,51,43,35,27,19,11,3,</span><br><span class="line">                    60,52,44,36,63,55,47,39,</span><br><span class="line">                    31,23,15,7,62,54,46,38,</span><br><span class="line">                    30,22,14,6,61,53,45,37,</span><br><span class="line">                    29,21,13,5,28,20,12,4 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>置换选择表PC2：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//置换选择表２</span><br><span class="line">int PC_2[]=&#123;14,17,11,24,1,5,</span><br><span class="line">                    3,28,15,6,21,10,</span><br><span class="line">                    23,19,12,4,26,8,</span><br><span class="line">                    16,7,27,20,13,2,</span><br><span class="line">                    41,52,31,37,47,55,</span><br><span class="line">                    30,40,51,45,33,48,</span><br><span class="line">                    44,49,39,56,34,53,</span><br><span class="line">                    46,42,50,36,29,32 &#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>子密钥产生核心代码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//子密钥产生</span><br><span class="line">int* generateSubKey(int key[],int turns)&#123;</span><br><span class="line">    int* subKey=new int[PC_1_LENGTH];</span><br><span class="line">    if(1==turns)&#123;//第１轮</span><br><span class="line">        //置换选择表PC1</span><br><span class="line">        int* tmp=repace_op(key,PC_1,PC_1_LENGTH);</span><br><span class="line">        //分为左右两部分</span><br><span class="line">        for(int i=0;i&lt;PC_HALF_LENGTH;i++)&#123;</span><br><span class="line">            //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;i+PC_HALF_LENGTH&lt;&lt;endl;</span><br><span class="line">            C[i]=tmp[i];</span><br><span class="line">            D[i]=tmp[i+PC_HALF_LENGTH];</span><br><span class="line">            //cout&lt;&lt;tmp[i+PC_HALF_LENGTH]&lt;&lt;&quot; &quot;&lt;&lt;D[i+PC_HALF_LENGTH]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        //将左右两部分向左进行循环位移</span><br><span class="line">        C=leftCycle(C,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        D=leftCycle(D,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        //将左右两部分进行拼接</span><br><span class="line">        for(int i=0;i&lt;PC_HALF_LENGTH;i++)&#123;</span><br><span class="line">            subKey[i]=C[i];</span><br><span class="line">            subKey[i+PC_HALF_LENGTH]=D[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //通过置换选择表PC2产生最终密钥</span><br><span class="line">        subKey=repace_op(subKey,PC_2,PC_2_LENGTH);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //将Ci-1、Di-1向左进行循环位移得到Ci、Di</span><br><span class="line">        C=leftCycle(C,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        D=leftCycle(D,PC_HALF_LENGTH,DISPLACEMENT_TURNS[turns-1]);</span><br><span class="line">        //将Ci、Di进行拼接</span><br><span class="line">        for(int i=0;i&lt;PC_HALF_LENGTH;i++)&#123;</span><br><span class="line">            subKey[i]=C[i];</span><br><span class="line">            subKey[i+PC_HALF_LENGTH]=D[i];</span><br><span class="line">        &#125;</span><br><span class="line">        //通过置换选择表PC2产生最终密钥</span><br><span class="line">        subKey=repace_op(subKey,PC_2,PC_2_LENGTH);</span><br><span class="line">    &#125;</span><br><span class="line">    return subKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="进行块加密"><a href="#进行块加密" class="headerlink" title="进行块加密"></a>进行块加密</h2><p>对64位原始数据通过IP表进行重新排列，将重新排列的数据分为左右两部分L、R（二者均为32位），通过如下步骤进行加密：</p>
<ol>
<li>Li=R(i-1)</li>
<li>Ri=L(i-1)⊕F(R(i-1),Ki)<br><br>DES算法一轮迭代过程：<br><br><img src="/images/DES算法一轮迭代过程.png" alt="DES算法一轮迭代过程"><br><br>F函数负责如下工作，对Ri-1通过表Ｅ进行扩展置换，置换结果(48bits)与Ki进行异或操作，然后将48bits数据分为８组，每组６bits，再通过S盒子得到32bits数据，一共有8个S盒子，每一个Ｓ盒子输入为６位输出为４位，通过P置换重新排列Ｓ盒子输出，最后将Li-1与Ｐ置换结果进行异或得到Ri。<br>E扩展置换表：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//扩展置换</span><br><span class="line">int E[]=&#123;32,1,2,3,4,5,</span><br><span class="line">                4,5,6,7,8,9,</span><br><span class="line">                8,9,10,11,12,13,</span><br><span class="line">                12,13,14,15,16,17,</span><br><span class="line">                16,17,18,19,20,21,</span><br><span class="line">                20,21,22,23,24,25,</span><br><span class="line">                24,25,26,27,28,29,</span><br><span class="line">                28,29,30,31,32,1&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>S盒子代替/选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//Ｓ盒子</span><br><span class="line">int S[][64]=&#123; &#123;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,//S1</span><br><span class="line">                      0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,</span><br><span class="line">                      4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,</span><br><span class="line">                     15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13 &#125;,</span><br><span class="line">                    &#123;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,//S2</span><br><span class="line">                    3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,</span><br><span class="line">                    0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,</span><br><span class="line">                    13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9&#125;,</span><br><span class="line">                    &#123;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,//S3</span><br><span class="line">                    13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,</span><br><span class="line">                    13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,</span><br><span class="line">                    1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12&#125;,</span><br><span class="line">                    &#123;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,//S4</span><br><span class="line">                    13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,</span><br><span class="line">                    10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,</span><br><span class="line">                    3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14&#125;,</span><br><span class="line">                    &#123;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,//S5</span><br><span class="line">                    14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,</span><br><span class="line">                    4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,</span><br><span class="line">                    11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3&#125;,</span><br><span class="line">                    &#123;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,//S6</span><br><span class="line">                    10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,</span><br><span class="line">                    9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,</span><br><span class="line">                    4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13&#125;,</span><br><span class="line">                    &#123;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,//S7</span><br><span class="line">                    13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,</span><br><span class="line">                    1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,</span><br><span class="line">                    6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12&#125;,</span><br><span class="line">                    &#123;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,//S8</span><br><span class="line">                    1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,</span><br><span class="line">                    7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,</span><br><span class="line">                    2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11&#125;</span><br><span class="line">                    &#125;;</span><br></pre></td></tr></table></figure></p>
<p>P置换表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//P置换表</span><br><span class="line">int P[]=&#123;16,7,20,21,</span><br><span class="line">            29,12,28,17,</span><br><span class="line">            1,15,23,26,</span><br><span class="line">            5,18,31,10,</span><br><span class="line">            2,8,24,14,</span><br><span class="line">            32,27,3,9,</span><br><span class="line">            19,13,30,6,</span><br><span class="line">            22,11,4,25</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>F函数核心代码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//ｆ函数</span><br><span class="line">int* f_func(int R[],int key[],int len)&#123;</span><br><span class="line">    //对数据有半部分进行扩展</span><br><span class="line">    int* er=repace_op(R,E,PC_2_LENGTH);</span><br><span class="line">    //扩展结果与密钥进行异或运算</span><br><span class="line">    int* xor_res=xor_op(er,len,key,len);</span><br><span class="line">    //对异或运算结果进行Ｓ盒子置换</span><br><span class="line">    int* s_box=sbox(xor_res,len);</span><br><span class="line">    //对Ｓ盒子输出结果进行Ｐ置换</span><br><span class="line">    int* res=repace_op(s_box,P,P_LENGTH);</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>S盒子核心代码</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//S盒子函数</span><br><span class="line">int* sbox(int data[],int len)&#123;</span><br><span class="line">    int* res=new int[32];</span><br><span class="line">    int d=len/S_BOX_IN_LEN;</span><br><span class="line">    for(int i=0;i&lt;d;i++)&#123;</span><br><span class="line">        int offset=i*S_BOX_IN_LEN;</span><br><span class="line">        //row</span><br><span class="line">        int row=0x00;</span><br><span class="line">        row=row|data[offset];</span><br><span class="line">        row=row&lt;&lt;1;</span><br><span class="line">        row=row|data[offset+S_BOX_IN_LEN-1];</span><br><span class="line">        //column</span><br><span class="line">        int column=0x00;</span><br><span class="line">        column=column|data[offset+1];</span><br><span class="line">        column=column&lt;&lt;1;</span><br><span class="line">        column=column|data[offset+2];</span><br><span class="line">        column=column&lt;&lt;1;</span><br><span class="line">        column=column|data[offset+3];</span><br><span class="line">        column=column&lt;&lt;1;</span><br><span class="line">        column=column|data[offset+4];</span><br><span class="line">        int index=row*16+column;</span><br><span class="line">        int output=S[i][index];</span><br><span class="line">        //S盒子元素选择</span><br><span class="line">        offset=i*HALF_BITS_LENGTH;</span><br><span class="line">        //Ｓ盒子选择结果只有４位</span><br><span class="line">        int* tmp=convertToBinaryArray(output);</span><br><span class="line">        for(int j=0;j&lt;HALF_BITS_LENGTH;j++)&#123;</span><br><span class="line">            res[offset+j]=tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        //保存选择结果至res数组</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p><strong>待加密数据：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int data_bin[]=&#123;0,0,0,0, 0,0,0,1, 0,0,1,0, 0,0,1,1, 0,1,0,0, 0,1,0,1, 0,1,1,0, 0,1,1,1, 1,0,0,0, 1,0,0,1, 1,0,1,0, 1,0,1,1, 1,1,0,0, 1,1,0,1, 1,1,1,0, 1,1,1,1&#125;;</span><br><span class="line">// 0123456789ABCDEF</span><br></pre></td></tr></table></figure></p>
<p><strong>加密密钥：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int key[]=&#123;0,0,0,1, 0,0,1,1, 0,0,1,1, 0,1,0,0, 0,1,0,1, 0,1,1,1, 0,1,1,1, 1,0,0,1, 1,0,0,1, 1,0,1,1, 1,0,1,1, 1,1,0,0, 1,1,0,1, 1,1,1,1, 1,1,1,1, 0,0,0,1&#125;;</span><br><span class="line">//133457799BBCCFF1</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/2018-05-15 21:25:54屏幕截图.png" alt="实验结果"><br><br><a href="https://github.com/ChengUU/ProgramEx/blob/master/CProgram/NS/DesEn.cpp">编码实现</a></p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = '[object Object]';
var disqus_identifier = '2018/11/21/DES算法原理详解及实现/';
var disqus_title = 'DES算法原理详解及实现';
var disqus_url = 'https://github.com/ChengUU/2018/11/21/DES算法原理详解及实现/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//[object Object].disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2018/11/21/Sublime-Text3安装激活/" class="prev">上一篇</a><a href="/2018/11/21/使用Hexo写博客/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://github.com/ChengUU">ChengUU</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script async src="https://tajs.qq.com/stats?sId=66115146" charset="UTF-8"></script></body></html>